---
comments: true
---

# 第三章 - 优先队列（堆）

在[数据结构基础 - 第四章 - 优先队列（堆）](https://victorwang712.github.io/Note/computer_science/data_structure_basics/chapter_4/)中，我们已经较为详细地讨论了「堆」这一数据结构。

但是我们也留下了一个问题，即一般的堆是难以合并的。以二叉堆为例，一个可行的合并方式是先将两个堆的数组拼接，然后采用线性建堆的方式，即从树的倒数第二层开始，对每一层的每一个节点执行下滤操作完成合并。容易直到这样操作的复杂度是线性的，这不够高效。

为了解决这个问题，我们将介绍几种高级的堆数据结构，来解决这一问题。

## 左式堆

**左式堆** (leftist heap) 也是满足堆序性的二叉树。但是相较一般的二叉堆，左式堆不仅不趋向**理想平衡** (perfectly balanced)，而且实际上的趋向于非常不平衡的。在具体构建这一数据结构前，我们需要引入一些概念。

### 左式堆的性质

我们将任意节点 $X$ 的**零路径长** (Null Path Length, NPL) $\texttt{Npl} (X)$ 定义为从 $X$ 到一个没有两个子节点的节点的最短路径长。

因此，具有 0 个或 1 个子节点的节点的 $\texttt{Npl}$ 为 $0$，$\texttt{Npl}(\texttt{NULL}) = -1$。同时一个重要的性质是，任意节点的零路径长比其所有子节点的零路径长的最小值多 $1$。

左式堆的性质是：对于堆中的每一个节点 $X$，左子节点的零路径长不小于右子节点的零路径长。显然这一性质会使得树偏向于向左增加深度，这也是其得名的由来。

进一步地，在右路径上有 $r$ 个节点的左式堆必然至少有 $2^{r} - 1$ 个节点。换言之，有 $N$ 个节点的左式堆有一条有路径最多含有 $\lceil \log (N + 1) \rceil$ 个节点。因此对左式堆操作的一般思路是将所有工作放到有路径上进行。于是我们关注的是，如何在对右路径进行插入和合并操作后回复左式堆的性质。

### 左式堆的操作

对左式堆的基本操作是合并。具体来说我们这样操作：

1. 比较两个左式堆的根节点，取较小的节点作为新堆的根，其左子树作为新堆的左子树；
2. 递归地合并较小节点的右子树和另一个堆，更新根节点的零路径长（即为右子节点的零路径长加 $1$）；
3. 如果合并完成后，右子树的零路径长大于左子树，则交换左子树和右子树。

执行合并的时间与右路径的长的和成正比，因为在递归调用期间对每一个被访问的节点执行的是常数工作量，因此合并两个左式堆的时间复杂度为 $O(\log N)$。

特别地，对左式堆插入一个新节点可以看作是向原堆合并一个单节点堆。

左式堆中删除最小值是容易的，只需要合并根节点的左右子堆即可。

## 斜堆

**斜堆** (skew heap) 是左式堆的自调节形式，实现起来较为简单。斜堆自身在结构上只要求保证堆序性，而不作类似于左式堆对零路径长等性质的要求。

### 斜堆的操作

能做到这一点的核心也在于斜堆的合并操作。具体来说，我们做以下操作：

1. 比较两个左式堆的根节点，取较小的节点作为新堆的根，其左子树作为新堆的左子树；
2. 递归地合并较小节点的右子树和另一个堆，更新根节点的零路径长（即为右子节点的零路径长加 $1$）；
3. 合并完成后，总是交换左子树和右子树。

可以看到，斜堆与左式堆的差异仅在于何时交换左右子树，在斜堆中交换是无条件的。

### 斜堆的复杂度分析

对于斜堆操作的复杂度，我们先给出结论。因为斜堆的右路径在任意时刻都可以任意长，所以所有操作的最坏情形运行时间都是 $O(N)$。

但是令人惊异的是，斜堆的操作可以保证对任意 $M$ 次连续操作，总的最坏情形运行时间是 $O(M \log N)$。因此斜堆每次操作的均摊复杂度是 $O(\log N)$。这一结论需要均摊分析加以证明。

???+ abstract "Proof"

    先给出一些定义：

    - 轻结点：右子树节点数不大于左子树节点数的节点。
    - 重结点：右子树节点数大于左子树节点数的节点。  
    - 势能函数 $\Phi (i)$：第 $i$ 次合并后，堆的重结点数。

    设总共进行 $M$ 次合并，斜堆的节点数始终不大于 $N$。

    考察第 $i$ 次操作，合并堆 $H_{1}$ 和 $H_{2}$。记堆 $H_{1}$ 右路径上有 $l_{1}$ 个轻节点、$h_{1}$ 个重节点；堆 $H_{2}$ 右路径上有 $l_{2}$ 个轻节点、$h_{2}$ 个重节点。那么这次合并的实际开销

    $$c_{i} = l_{1} + h_{1} + l_{2} + h_{2}$$

    合并完成后，右路径上原本的重结点一定会变为轻节点，因为其本身右子树比左子树节点数多，且合并又发生在右子树上，于是交换左右子树后该节点的左子树一定比右子树节点数多。而轻节点是否变为重结点是不好确定的，于是我们考虑最坏情况，即所有轻节点都变为重结点。那么本次合并的势能变化

    $$\Delta \Phi_{i} \leq l_{1} + l_{2} - h_{1} - h_{2}$$

    均摊开销等于实际开销加势能变化，即

    $$\hat{c}_{i} = c_{i} + \Delta \Phi \leq 2 l_{1} + 2 l_{2} \leq 2 \log N$$

    于是全部 $M$ 次操作的均摊开销为

    $$\sum_{i = 1}^{M} \hat{c}_{i} = \sum_{i = 1}^{M} c_{i} + \Phi_{M} - \Phi_{0}$$

    又考虑到 $\Phi_{0}, \Phi_{M} \in [0, N]$，于是

    $$\sum_{i = 1}^{M} c_{i} + \Phi_{M} - \Phi_{0} \leq 2 M \log N + 2 N$$

    于是每次操作的均摊复杂度即为 $O(\log N)$。
